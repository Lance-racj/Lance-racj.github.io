[{"title":"HTML5新特性","url":"/2021/11/21/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/","content":"<h5 id=\"1-增加了许多新的语义化标签\"><a href=\"#1-增加了许多新的语义化标签\" class=\"headerlink\" title=\"1.增加了许多新的语义化标签\"></a>1.<em>增加了许多新的语义化标签</em></h5><p>盒子本质上没有区别，但是在语义上有了很好的区分。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">header</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span>\t\t<span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span>\t\t<span class=\"tag\">&lt;<span class=\"name\">nav</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">nav</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">section</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">section</span>&gt;</span>(类似于div,一块区域)\t\t   <span class=\"tag\">&lt;<span class=\"name\">article</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">article</span>&gt;</span>(内容区域)</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">aside</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">aside</span>&gt;</span>(侧边栏)  <span class=\"tag\">&lt;<span class=\"name\">dialog</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">dialog</span>&gt;</span>(对话提示框)    <span class=\"tag\">&lt;<span class=\"name\">summary</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">summary</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">details</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">details</span>&gt;</span>(描述某处细节,summary是其第一个子元素)</span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<hr>\n<h5 id=\"2-视频与音频标签\"><a href=\"#2-视频与音频标签\" class=\"headerlink\" title=\"2.视频与音频标签\"></a>2.<em>视频与音频标签</em></h5><h6 id=\"视频标签-gt\"><a href=\"#视频标签-gt\" class=\"headerlink\" title=\"视频标签 =&gt;\"></a><strong>视频标签</strong> =&gt;</h6><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">video</span> <span class=\"attr\">width</span> = <span class=\"string\">&quot;300px&quot;</span> <span class=\"attr\">height</span> = <span class=\"string\">&quot;100px&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sourse</span> <span class=\"attr\">src</span> = <span class=\"string\">&quot;movie.mp4&quot;</span> <span class=\"attr\">type</span> = <span class=\"string\">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">video</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><em>video标签属性：</em></p>\n<ul>\n<li><p>controls = “controls”     // 显示控件</p>\n</li>\n<li><p> loop = “loop”       // 循环播放</p>\n</li>\n<li><p> autoplay = “autoplay”    //  自动播放</p>\n</li>\n<li><p>muted = “muted”    //  静音</p>\n</li>\n<li><p>poster = url(xxx)      //  封面</p>\n</li>\n</ul>\n<h6 id=\"音频标签-gt\"><a href=\"#音频标签-gt\" class=\"headerlink\" title=\"音频标签 =&gt;\"></a>音频标签 =&gt;</h6><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">audio</span> <span class=\"attr\">width</span> = <span class=\"string\">&quot;300px&quot;</span> <span class=\"attr\">height</span> = <span class=\"string\">&quot;100px&quot;</span> <span class=\"attr\">controls</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">sourse</span> <span class=\"attr\">src</span> = <span class=\"string\">&quot;music.mp3&quot;</span> <span class=\"attr\">type</span> = <span class=\"string\">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>audio标签属性与video一样，但值得注意的是，如果音频静音，那将毫无意义。</p>\n<p>此外，video与audio标签内都可以直接写src属性，可以不用包裹source标签。</p>\n<hr>\n<h5 id=\"3-新技术-Web-Storage-本地存储\"><a href=\"#3-新技术-Web-Storage-本地存储\" class=\"headerlink\" title=\"3.新技术 Web Storage 本地存储\"></a>3.<em>新技术 Web Storage 本地存储</em></h5><p>在之前的HTML版本中，都是用cookie来行使本地存储功能，但其有一些不足之处，最主要的就是容量太小，只能存储大概4KB的内容，因此H5提出了Web Storage。(分为localStorage和sessionStorage两种)</p>\n<h6 id=\"sessionStorage-gt\"><a href=\"#sessionStorage-gt\" class=\"headerlink\" title=\"sessionStorage =&gt;\"></a>sessionStorage =&gt;</h6><p>特点：内存大概在5MB左右。</p>\n<p>​            如果关闭浏览器或者页面后数据将不复存在，它的生命周期就是那个页面。</p>\n<p>​            数据是保存于当前页面中的，与别的页面不会共享。</p>\n<h6 id=\"loaclStorage-gt-（没有时间限制的本地存储）\"><a href=\"#loaclStorage-gt-（没有时间限制的本地存储）\" class=\"headerlink\" title=\"loaclStorage =&gt; （没有时间限制的本地存储）\"></a>loaclStorage =&gt; （没有时间限制的本地存储）</h6><p>特点：内存大概在20MB左右。</p>\n<p>​            不同浏览器之间不共享，但同一浏览器之中不同网页之间是可以共享数据的。</p>\n<p>​            关闭浏览器之后，数据依然存在。</p>\n<p><em><strong>二者通用的API（此处以localStorage为例）如下 =&gt;</strong></em> </p>\n<p>保存data：localStorage.setItem(key,value);</p>\n<p>读取data：localStorage.getItem(key);</p>\n<p>删除某一data：localStorage.removeItem(key);</p>\n<p>删除所有的data：localStorage.clear();</p>\n<hr>\n<h5 id=\"4-web-Socket\"><a href=\"#4-web-Socket\" class=\"headerlink\" title=\"4. web Socket\"></a>4. <em>web Socket</em></h5><p>​        一种在单个TCP连接上进行全双工通信的协议，只需要客户端与服务器进行一次握手，然后无需HTTP连接，直接基于TCP连接就可以交换数据，客户端发送数据到服务器使用send()方法，接受服务器发来的消息用onmessage事件来进行接受。</p>\n<hr>\n<h5 id=\"5-web-worker\"><a href=\"#5-web-worker\" class=\"headerlink\" title=\"5. web worker\"></a>5. <em>web worker</em></h5><p>支持异步执行js文件，避免页面卡死。（像js脚本的defer与anysc属性就完成的这个功能）</p>\n<hr>\n<h5 id=\"6-Canvas标签\"><a href=\"#6-Canvas标签\" class=\"headerlink\" title=\"6. Canvas标签\"></a>6. <em>Canvas标签</em></h5><p>创建一个可绘图框，可以在其中进行绘图，但是想要绘图还是需要js来执行。</p>\n<hr>\n<h5 id=\"7-增强型表单-Input\"><a href=\"#7-增强型表单-Input\" class=\"headerlink\" title=\"7. 增强型表单 Input\"></a>7. <em>增强型表单 Input</em></h5><p>比如color，date，email，url，search类型的输入框等等。</p>\n<p>还有一些比较常用的属性，不太常用的此处并未列举：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">required\t//布尔类型，输入不能为空</span><br><span class=\"line\">autofocus\t//布尔类型，页面加载以后输入框自动获得焦点</span><br><span class=\"line\">min/max\t\t//设置可输入元素的最大值与最小值</span><br><span class=\"line\">placehoder\t//输入前默认提示，输入后提示消失</span><br><span class=\"line\">pattern\t\t//正则表达式，匹配输入</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","categories":["前端基础"],"tags":["HTML5"]},{"title":"CSS实现水平垂直居中","url":"/2021/11/21/CSS%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","content":"<h4 id=\"实现一个div盒子在页面内的水平垂直居中\"><a href=\"#实现一个div盒子在页面内的水平垂直居中\" class=\"headerlink\" title=\"实现一个div盒子在页面内的水平垂直居中\"></a><em>实现一个div盒子在页面内的水平垂直居中</em></h4><p>123 =&gt;</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>45 =&gt;</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span> = <span class=\"string\">&quot;box&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<span id=\"more\"></span>\n\n<h6 id=\"1-绝对定位-负margin\"><a href=\"#1-绝对定位-负margin\" class=\"headerlink\" title=\"1. 绝对定位 + 负margin\"></a>1. 绝对定位 + 负margin</h6><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-left</span>: -<span class=\"number\">100px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: -<span class=\"number\">100px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"2-绝对定位-margin-auto\"><a href=\"#2-绝对定位-margin-auto\" class=\"headerlink\" title=\"2. 绝对定位 + margin:auto\"></a>2. 绝对定位 + margin:auto</h6><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"3-绝对定位-transform-translate\"><a href=\"#3-绝对定位-transform-translate\" class=\"headerlink\" title=\"3. 绝对定位 + transform(translate)\"></a>3. 绝对定位 + transform(translate)</h6><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: absolute;  //定位是父级元素(带relative)的<span class=\"number\">50%</span></span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: <span class=\"built_in\">translate</span>(-<span class=\"number\">50%</span>,-<span class=\"number\">50%</span>);  //translate是自身的<span class=\"number\">50%</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"4-flex-布局\"><a href=\"#4-flex-布局\" class=\"headerlink\" title=\"4. flex 布局\"></a>4. flex 布局</h6><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">600px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">justify-content</span>: center;  //子元素水平居中</span><br><span class=\"line\">    <span class=\"attribute\">align-items</span>: center;   //子元素垂直居中</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#box</span> <span class=\"selector-tag\">div</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h6 id=\"5-table-布局\"><a href=\"#5-table-布局\" class=\"headerlink\" title=\"5. table 布局\"></a>5. table 布局</h6><figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#box</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">600px</span>;\t//父盒子必须加宽高，不然大小和子盒子一样</span><br><span class=\"line\">    <span class=\"attribute\">width</span>:<span class=\"number\">600px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: table-cell;</span><br><span class=\"line\">    <span class=\"attribute\">text-align</span>: center;  //水平居中</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;  //垂直居中</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-id\">#box</span> <span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;  //子元素必须设置为行内块元素</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","categories":["CSS"],"tags":["CSS"]},{"title":"HTTP版本区别","url":"/2021/11/20/HTTP%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/","content":"<h5 id=\"1-HTTP-1-0-与-HTTP-1-1-的区别\"><a href=\"#1-HTTP-1-0-与-HTTP-1-1-的区别\" class=\"headerlink\" title=\"1.HTTP 1.0 与 HTTP 1.1 的区别\"></a>1.<em>HTTP 1.0 与 HTTP 1.1 的区别</em></h5><ul>\n<li><p><strong>连接</strong> =&gt; 在HTTP 1.0 中使用短连接，也就是说每发一次HTTP请求都要经历TCP三次握手四次挥手的这个过程，这样明显效率是很低的。为了解决这个问题，在HTTP 1.1 中使用了长连接(keep-alive)，连接之后不会断开，即就是一次TCP连接可以发送很多次HTTP请求，不用去每次都连接一下TCP。</p>\n<span id=\"more\"></span>\n\n<p>而HTTP 1.1的长连接又可以分为流水线式和非流水线式。流水线式就是指发完上一个请求后，不用等待上一个请求的响应返回就可以发送下一个请求，(请求不是同时发的)。而非流水线式指必须等到上一个响应后才可以发送下一个请求。</p>\n</li>\n<li><p><strong>错误状态响应码</strong> =&gt; 在HTTP 1.1中新增了24个状态码，比如409(请求资源与该资源目前的状态冲突)，410(服务器上的某个资源被永久性的删除)。</p>\n</li>\n<li><p><em><strong>HTTP 1.1中开始有host（域）这个概念</strong></em></p>\n</li>\n<li><p><strong>带宽优化及网络连接的使用</strong> =&gt; 在HTTP 1.0中，有时候我们只需要一个对象的一部分，服务器却将整个对象都传输了过来，浪费了带宽，在HTTP 1.1中，头部引入了range，也就是可以只请求数据的一部分，优化了带宽，同时，它还支持断点重传与并行下载。</p>\n</li>\n<li><p><strong>缓存处理</strong> =&gt; HTTP 1.0中使用header的Expires和If-Modefined-Since作为缓存判断的标准，在HTTP 1.1中引入了更多缓存控制策略。</p>\n</li>\n</ul>\n<hr>\n<h5 id=\"2-HTTP-2-0-有什么新特性？\"><a href=\"#2-HTTP-2-0-有什么新特性？\" class=\"headerlink\" title=\"2.HTTP 2.0 有什么新特性？\"></a>2.<em>HTTP 2.0 有什么新特性？</em></h5><p>   在了解HTTP 2.0新特性之前，先了解一下<em>HTTP 1.1 存在的一些问题</em></p>\n<ol>\n<li><p>不会压缩请求与响应报文的首部，导致不必要的网络流量。</p>\n</li>\n<li><p>不支持有效的资源优先级。</p>\n</li>\n<li><p>需要多个TCP连接才可以实现高并发(设想一下有50个请求同时请求服务器，1.1则需要50个连接，在同一个连接里面没法并发)。</p>\n<p>下面让我们正式进入HTTP 2.0，<em>看看新加了什么特性</em>？</p>\n</li>\n</ol>\n<ul>\n<li><strong>使用了二进制格式</strong>，而不是文本格式，可以将信息分为更小的二进制消息与帧。</li>\n<li><strong>首部压缩</strong>，使用报头压缩，降低开销。</li>\n<li><strong>(重点)多路复用</strong> =&gt; 就是说在一个HTTP连接里面可以同时发起多个请求与响应，实现了高并发。</li>\n</ul>\n<p><img src=\"/2021/11/20/HTTP%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg\" alt=\"多路复用\"></p>\n<ul>\n<li><p><strong>支持服务器推送</strong> =&gt; 服务器可以经过计算主动将数据放至客户端缓存中。(举个例子，一个客户端请求了一个HTML文件，服务器就会知道它还需要例如css，js文件等很多附加资源，就会主动地将它们推送到客户端)，这样客户端下次就会直接从缓存中读取数据，这样就会节省很多时间。</p>\n</li>\n<li><p><strong>更好的利用带宽速度</strong> =&gt; 由于TCP连接是慢启动(开始会限制传输速度，随着时间的推移以及数据的成功传输，速度会逐渐提升)，如果是HTTP 1.1，高并发时每个连接都要经历这个慢启动的过程，在2.0中，只需要一个TCP连接，也就只需要经历一次慢启动过程，可以更高效的利用高速带宽。</p>\n</li>\n</ul>\n","categories":["HTTP"],"tags":["HTTP"]},{"title":"今日头条前端面试输出题","url":"/2021/11/20/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%BE%93%E5%87%BA%E9%A2%98/","content":"<h5 id=\"观察以下代码，说出它的输出结果以及原因\"><a href=\"#观察以下代码，说出它的输出结果以及原因\" class=\"headerlink\" title=\"观察以下代码，说出它的输出结果以及原因\"></a><em>观察以下代码，说出它的输出结果以及原因</em></h5><span id=\"more\"></span>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tgetName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.getName();</span><br><span class=\"line\">getName();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Foo().getName();</span><br><span class=\"line\">getName();</span><br><span class=\"line\">Foo().getName();</span><br></pre></td></tr></table></figure>\n\n<p>公布答案：<code>21400</code>，下面是解析。</p>\n<p><em><strong>解析</strong></em> =&gt; 先来看第一个函数调用</p>\n<h6 id=\"1-Foo-getMame\"><a href=\"#1-Foo-getMame\" class=\"headerlink\" title=\"1.Foo.getMame()\"></a>1.<strong>Foo.getMame()</strong></h6><p>Foo此时被当作对象来看待，我们调用了这个对象的getName()方法，首先看Foo自身有没有这个方法，如果没有，就去原型链去找。</p>\n<p>路径 <code>Foo-&gt;Function.prototype-&gt;Object.prototype-&gt;null </code>。箭头代表引用该对象的<code> __proto__</code> 属性。</p>\n<p>在源代码中，这段代码给Foo加上了getName方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Foo.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以第一个函数调用打印了2。接着来看第二个函数调用</p>\n<h6 id=\"2-getName\"><a href=\"#2-getName\" class=\"headerlink\" title=\"2.getName()\"></a>2.<strong>getName()</strong></h6><p>源代码中，共定义了两个getName()，那么会调用哪个呢？由于JavaScript的预编译机制，我们知道var和function定义的函数都会被提升，但是function定义的函数是在预编译阶段，而var定义的函数是在函数解释执行阶段，因此下面两个代码是等价的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//........</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//........</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getName</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//........</span></span><br><span class=\"line\">getName();</span><br></pre></td></tr></table></figure>\n\n<p>等价于</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//........</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//........</span></span><br><span class=\"line\">getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//........</span></span><br><span class=\"line\">getName();</span><br></pre></td></tr></table></figure>\n\n<p>因此我们可以得到会打印结果1。function定义的函数是先定义的，后来被覆盖掉了。再来看第三个函数调用</p>\n<h6 id=\"3-new-Foo-getName\"><a href=\"#3-new-Foo-getName\" class=\"headerlink\" title=\"3.new Foo().getName()\"></a>3.<strong>new Foo().getName()</strong></h6><p>这是一个Foo实例化的对象(下文称为foo)，来调用自己的getName方法，首先看foo自身有没有这个属性，如果没有就会去原型链上去找，路径<code>foo-&gt;Foo.prototype-&gt;Object.prototype-&gt;null</code>，显然我们可以看到第一个被访问到的getName应该是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Foo.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>值得注意的是，在Foo函数中有一个getName方法，很多人会误以为它就是Foo自身的属性，但其实它没有加var，它是一个全局的属性，因此我们可以得到结果打印为 4 。接下来看第四个</p>\n<h6 id=\"4-getName\"><a href=\"#4-getName\" class=\"headerlink\" title=\"4.getName()\"></a>4.<strong>getName()</strong></h6><p>为什么和第二个明明一样，结果却不一样呢？很简单，在第三步的时候，new Foo()调用了Foo这个函数，而Foo这个函数又定义了一个新的全局属性getName方法将原来的getName方法覆盖掉。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\tgetName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此再调用getName()方法自然就会打印 0 了。来看最后一个</p>\n<h6 id=\"5-Foo-getName\"><a href=\"#5-Foo-getName\" class=\"headerlink\" title=\"5.Foo().getName()\"></a>5.<strong>Foo().getName()</strong></h6><p>全局作用下，直接调用Foo是由window/global调用的，因此返回的this是window/global，所以会调用全局下的getName，所以也会打印出 0 。</p>\n","categories":["代码输出题"],"tags":["输出题","预编译"]},{"title":"小红书前端面试输出题","url":"/2021/11/21/%E5%B0%8F%E7%BA%A2%E4%B9%A6%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%BE%93%E5%87%BA%E9%A2%98/","content":"<h5 id=\"观察以下代码，说出它的输出结果以及原因\"><a href=\"#观察以下代码，说出它的输出结果以及原因\" class=\"headerlink\" title=\"观察以下代码，说出它的输出结果以及原因\"></a><em>观察以下代码，说出它的输出结果以及原因</em></h5><span id=\"more\"></span>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async3();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;3&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;4&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;5&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;6&#x27;</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;7&#x27;</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;8&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><em><strong>公布答案：513794826</strong></em></p>\n<p><em>下面一起来看一下解析 =&gt;</em></p>\n<p>通过代码，我们不难看出第一个执行的语句是</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;5&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果 5 。</strong></p>\n<p>接着遇到了setTimeout函数，但是了解JavaScript事件循环机制的话，就会明白，setTimeout是一个宏任务，它会被放入宏任务队列里面，等到同步任务和微任务都执行完毕后再执行，因此setTimeout加入宏任务队列，代码继续向下执行。</p>\n<p>这时候调用了async1函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async3();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//...............</span></span><br><span class=\"line\">async1();</span><br></pre></td></tr></table></figure>\n\n<p>不难得出，<strong>第一句话输出 1</strong> 。第二句话值得注意的是，与一般代码语句不同的是，await语句会先执行代码的右边部分，因此async2会先执行，<strong>输出结果 3</strong> 。接着遇到await，第二句话进入微任务队列，同时async1函数暂时中止，跳出到外部继续执行后续代码。</p>\n<p>下面我们遇到了一个Promise函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;7&#x27;</span>);</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;8&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>根据所学的经验，Promise函数的构造器部分是同步执行的，then部分是加入微任务队列的，因此<strong>首先7会被先输出</strong>，then里面的内容加入微任务队列。</p>\n<p>接着下一句代码很简单，直接就会执行（<strong>输出9</strong>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;9&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这个时候，这段代码的同步代码都已经执行完了，根据JavaScript事件循环机制，接着我们会进入微任务队列执行，微任务队列中此时有两个任务，await async2和then，首先执行前者。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;1&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async2();</span><br><span class=\"line\">    <span class=\"keyword\">await</span> async3();</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;2&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行完await async2();之后，这段语句才算是真正结束，接着和async2一样，先执行代码右边部分，定义可知，<strong>会输出4</strong> 。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">async3</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;4&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出完后，又会将await async3(); 加入微任务队列，根据微任务队列顺序，下一个执行的是Promise的then部分，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">xxx..then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;8&#x27;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果8</strong>，返回async1中的await async3();中，执行完毕，微任务队列执行完毕，还剩下两个步骤，底下的同步代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;2&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;6&#x27;</span>);</span><br><span class=\"line\">&#125;,<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>和setTimeout宏任务，肯定会先执行同步代码，<strong>输出 2</strong> 。接着执行定时器函数，<strong>输出结果 6</strong> 。</p>\n","categories":["代码输出题"],"tags":["输出题","promise"]},{"title":"如何自己动手写一个深拷贝呢（外加数组判断方法）","url":"/2021/11/22/%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%91%A2/","content":"<p>​    <em>在我们编写代码的时候，经常会发生当我们去定义一个变量，将一个对象或者数组赋值给这个变量时，我们修改了变量的值，但是却发现原来的那个数组或变量值也已经改变了。这就是JavaScript的浅拷贝带来的问题，它只会拷贝第一层，(原理上来说拿到的是对象/数组在堆中的地址)不会去深入，当然也有深拷贝函数的存在，但是今天，我们的目的是自己来实现一个深拷贝函数。</em></p>\n<h5 id=\"1-JavaScript深拷贝\"><a href=\"#1-JavaScript深拷贝\" class=\"headerlink\" title=\"1. JavaScript深拷贝\"></a>1. JavaScript深拷贝</h5><span id=\"more\"></span>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//递归的出口以及判断obj是不是空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj === <span class=\"literal\">null</span> || obj !== <span class=\"string\">&#x27;object&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> result;</span><br><span class=\"line\">    <span class=\"comment\">//思考题1:为什么这里不能用typeof来判断数组呢？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>) &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        result = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//开始深拷贝（递归）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//只拷贝对象自身的属性，不拷贝原型属性</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class=\"line\">            result[key] = deepClone(obj[key]);</span><br><span class=\"line\">    \t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h6 id=\"2-思考题-1题解-gt\"><a href=\"#2-思考题-1题解-gt\" class=\"headerlink\" title=\"2. 思考题 1题解 =&gt;\"></a>2. <em>思考题 1题解</em> =&gt;</h6><p>其实Array也是继承于Object的，在JavaScript数据类型中，是不存在数组这一数据类型的，无论是数组还是对象，调用typeof都会返回Object。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr1 = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Array</span>);  <span class=\"comment\">//false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1 <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span>);  <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>instanceof是会通过原型链去寻找后边跟的类型，找到返回true，找不到返回false。</p>\n<hr>\n<p>思考题 2：说到这里又有一个新的问题了，除了instanceof还有其他方法吗？还有instanceof就一定可靠吗？</p>\n<p>//…………………………先想一想 5min。</p>\n<h6 id=\"3-思考题-2题解-gt\"><a href=\"#3-思考题-2题解-gt\" class=\"headerlink\" title=\"3. 思考题 2题解 =&gt;\"></a>3. <em>思考题 2题解</em> =&gt;</h6><p>好了，想明白了吗，<del>首先instanceof是不可靠的</del>，为什么呢？假如现在有两个页面A和B，我们知道A和B的window对象是不同的，因此在他们各自底下的Array也是不同的。现在业务需要，需要将A的一个数组传到B去，这时候我们在B页面中调用 [] instanceof Array，此时这个Array是B页面的，但是这个数组是由A页面创建的，因此在[]的原型链上是找不到B页面的Array的，返回的结果会是false。</p>\n<p>综上所述，instanceof 适用于在同一页面的情况下使用。</p>\n<p><em>那么还有什么方法可以判断一个变量是不是一个数组呢？</em></p>\n<p>（1）目前最可靠的方法就是 <strong>isArray()</strong> 方法</p>\n<p>（2）还有通过Object.prototype.toString.call()   这个方法我也不是很清楚，很少会去使用。</p>\n","categories":["原理实现"],"tags":["JavaScript","原理剖析"]}]